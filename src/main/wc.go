package main

import (
	"container/list"
	"fmt"
	"os"
	"strconv"

	"6.824/src/mapreduce"
)



func isAlpha(ch uint8) bool {
	return ch <= 'z' && ch >= 'a' || ch <= 'Z' && ch >= 'A'
}

func Map(value string) *list.List {
	// value为一个文件的内容
	// 输出应该是单词的频次
	fmt.Println(value)
	// value应该是一个字符串，统计里面的单词就可以了
	counts := make(map[string]int)
	tmp := ""
	for i, _ := range value {
		if isAlpha(value[i]) {
			tmp += string(value[i])
		} else {
			if tmp != "" {
				counts[tmp] = counts[tmp] + 1
				tmp = ""
			}
		}
	}
	res := list.New()
	for word, count := range counts {
		res.PushBack(mapreduce.KeyValue{Key: word, Value: strconv.Itoa(count)})
	}
	return res
}

// called once for each key generated by Map, with a list
// of that key's string value. should return a single
// output value for that key.
func Reduce(key string, values *list.List) string {
	count := 0
	for iter := values.Front(); iter != nil; iter = iter.Next() {
		add, err := strconv.Atoi(iter.Value.(string))
		if err != nil {
			return ""
		}
		count += add
	}
	res := strconv.Itoa(count)
	return res
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master x.txt sequential)
// 2) Master (e.g., go run wc.go master x.txt localhost:7777)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)
func main() {
	if len(os.Args) != 4 {
		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
	} else if os.Args[1] == "master" {
		if os.Args[3] == "sequential" {
			// part1会运行到这里
			// 这里是运行一个mapreduce集群，5个map进程、3个reduce进程
			mapreduce.RunSingle(5, 3, os.Args[2], Map, Reduce)
		} else {
			mr := mapreduce.MakeMapReduce(5, 3, os.Args[2], os.Args[3])
			// Wait until MR is done
			<-mr.DoneChannel
		}
	} else {
		mapreduce.RunWorker(os.Args[2], os.Args[3], Map, Reduce, 100)
	}
}
